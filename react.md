get started:

Component：

组件接受多个parameter(参数)，称做(props)，返回用来展示render方法中的层次视图。

render方法返回一个视图结构并将其渲染到页面上。
返回的视图结构为一个React element(React元素),
为一个轻量级的结构描述。
大多数React开发者使用JSX语法来写这种结构。
<div>在构建的时候会被转化为React.createElement("div")

举例：

<div className="shopping-list">
    <h1>Shopping list</h1>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
</div>

在构建的时候会被转化为：

`
    React.createElement("div",{ className: "shopping-list",},
        React.createElement("h1",...),
        React.createElement("ul",...)
    )

`

你可以在JSX中的括号中书写任何JS表达式，每一个React元素都是一个可以存储在一个变量或者在应用中传递的真实对象

ShoppingList组件只能渲染内置的DOM组件，但是你通过书写例如<ShoppingList>来构建自定义React组件。
每个组件都是封装好的可以独立操作，所以可以通过组件系统来构建复杂的UI。


React组件可以通过在constructor中通过设置this.state,从而拥有状态
this.state为组件的private成员，可以保存组件的当前状态

在组件中明确声明的constructor方法(其实也是是派生类的构造过程)中，必须明确调用super函数(基类构造函数)


React元素不可变，一旦创建该元素，就不能更改其子元素或者属性
一个React元素相当于电影里的一个独立帧：表示一个特定时间的UI层

当需要更新React元素时，唯一的方法就是创建一个新的React元素，并且传递个ReactDOM.render方法

react只对有必要更新的内容进行更新


#### 组件Component和属性Prop

组件使得开发者将整个UI层分割为多个可重用的彼此之间独立的组件。
从概念来讲，组件类似JavaScript中的函数。接受任意输入(props)并返回React元素用于描述渲染到屏幕上的DOM结构

#### 函数式和类式组件

最简单的定义组件的方式是定义一个接受属性参数(props),返回一个表示DOM结构的React元素的函数
除此之外，你还可以使用ES6的class特性定义组件.

渲染组件:
React元素除了可以表示DOM结构外，还可以表示用户自定义组件。
当React观察到React元素表示用户自定义组件时，jsx属性将被看作一个独立对象传递到到该组件，称之为props
其中，jsx语法中标签上的属性整合为一个props对象，该对象中包含所有和标签上属性同名的键值对。

##### 组件构成

组件可以引用其他组件，从而构成组件系统直至整个应用

组件函数/类的render方法中返回的根节点只能是1个

##### 组件拆分

鼓励将组件分割为更小粒度的组件
组件的props命名时应该站在组件自己的观点，而不是上下文的角度来命名该属性
当UI层中的一个部分多次使用或者自身逻辑足够复杂时，就应该设计为一个可重用的组件

##### props(属性)只读

纯函数：不改变输入数据的函数

__所有React组件都表现为类似纯函数，不对其props产生影响__



#### 状态和生命周期

ReactDOM.render(reactElement,container ) 修改渲染输出

状态和props类似，但是状态为private，完全由组件本身控制。

class式声明组件的另一个好处就是实现本地状态(private state)
除此之外另一个特性就是生命周期挂钩

##### 函数式声明组件 => 类式声明组件:

1. 创建ES6 类 (类名与函数名、React组件名相同) 继承自 React.Component
2. 添加一个单独的空方法叫做render
3. 将函数中函数体移到render方法中
4. 在render方法中用this.props替换函数中的props
5. 删除之前的函数声明


##### 给React组件类添加本地状态

1. 在render方法中将props对象中属性用state对象的同名属性代替
2. 添加一个类构造函数(传入参数props)来初始化this.state对象(该构造函数还需要调用基类React.Component的构造函数)


##### 给React组件类添加生命周期方法

对于包含多个组件的应用而言，释放无用组件占用的资源是十分重要的降低应用占用的方法。
以Clock为例：当渲染其DOM结构时，我们为其添加计时器，在React中称之为 挂载(mount)
当删除其DOM结构，清除计时器，在React中称之为 卸载(unmount)
我们可以声明特殊方法来让其在组件挂载/卸载时自动执行,这些方法被称为生命周期钩子方法


当React构造函数被调用，传入props参数，你可以给this.state添加额外的字段来存储一些数据

如果你有些数据不在render中使用，则他们不应该在state中


1. 当React组件对应的自定义标签被传入ReactDOM.render方法时，React调用自定义标签对应React组件的构造函数。
当该React组件需要被渲染到屏幕上时，初始化this.state。
2. React调用组件的render方法(该方法告诉React需要渲染到屏幕上的DOM结构),用组件对应的渲染输出结果去更新DOM
3. 当组件的渲染输出结果插入到DOM中时，React调用组件的 __componentDidMount__这一生命周期钩子函数
4. 组件通过调用setState方法更新状态,然后React得知状态更新后会重新调用render，更新父组件的DOM
5. 当组件从父组件中移除后，React调用componentWillUnmount这一生命周期钩子函数。


##### 正确使用状态(State)

1. 通过setState方法设置状态:建议通过使用setState方法传入待修改的状态对象的属性构成的对象(例如{comment:"Hello"})而不是直接为状态对象赋值
2. 状态更新为异步: React可能在一次更新中多次调用setState方法。this.props和this.state异步更新。所以不能利用props和state当前值去计算下次更新后的值.
若需要获取state之前值则可以使用setState的重构形式：
此时，setState方法接受一个函数而不是一个对象，该函数接受一个之前的状态state，二参则是传入的props用来对state进行更新
3. 状态更新的合并:当调用setState方法时，React将传入的对象和当前的state对象合并 __?(没理解)__
4. 组件之间不清楚彼此是否为状态组件或者无状态组件。所以状态被称为本地或者封装。对除某组件本身拥有和可设置以外，其他组件都不能获取到该组件状态。
组建可以选择通过props将自身state传递给其子组件。一般将这种称为"自上而下"或者"单向"数据流.只有在组件树中处于祖先节点的组件才能通过其state影响子组件.
组件树可以理解为一条河流，组件树上的每个组件都是这颗树上的一个支流，将其state作为props流入这条河流

#### 事件处理
React元素的事件处理和DOM元素的事件处理类似，但存在以下句法区别:
1. 使用React事件使用驼峰命名法
2. JSX语法中传递函数作为时间处理程序而不是字符串
写法如下:
<button onClick={activateLasers}>
    xxxx
</button>
3. 事件处理程序不能只通过返回false来阻止默认行为的触发，需要手动调用preventDefault。React对事件的定义遵循W3C标准，所以无需考虑浏览器兼容性

### 该章之后理解有误，需要重新学习

在JSX的回调函数中需要认真理解this的含义。在JS中，类的方法默认不绑定到类。如果忘记绑定事件处理程序到this对象(React组件)并且将其传递给事件(例如:onClick)，事件处理程序调用时this将会是undefined而不是React组件对象


#### 条件渲染
条件渲染:根据当前应用当前状态选择性渲染一部分组件
与JS条件判断类似，使用 if 或者 条件操作符 判断来选择在UI层展示部分组件

##### 元素变量
可以使用变量保存元素。当除某个组件外其他渲染的组件均未发生变化时，用变量保存的组件可以条件渲染该组件。

##### 内联if运算符和逻辑&&内联运算符
可以在JSX中通过大括号包裹表达式实现嵌入任何表达式的功能。
其中包括JS中的逻辑&&内联运算符,根据该方式可以实现条件渲染组件

##### if else 语句

##### 阻止组件渲染

有些时候，我们希望在使用子组件的父组件渲染时隐藏子组件,
此时我们在通过父组件对子组件传入props设置其state时，若props中操作该子组件显隐的属性为false时，子组件渲染结果返回null阻止子组件渲染。

#### 列表和键值对

##### 多组件渲染
可以创建组件集合保存在变量中并且使用大括号在JSX中包裹它们,通过map迭代方法创建多个组件

##### 基本列表组件

对于列表组件中每个基本组件，需要提供一个 键(key) 去识别每个基本组件。

##### 键(key)

Key帮助React去识别是哪个基本组建发生了变化。key需要添加到组件DOM结构作为一个属性key存在。
key的设置最好用组件的唯一标识符，通常使用组件包含的数据的ID来标识
如果简单数据，不包含ID时，根据下标来标识组件,但是这种情况下，对当前组件进行再次排序十分困难

##### 根据 Key 提取组件

__将Key提取到组件DOM节点中属性的位置，而不是待渲染的DOM结构中,即将key属性的设置放置在map迭代方法中__

##### key必须在同级组件中唯一标识该组件

兄弟组件的key属性值必须两两不相同，但是key属性值可以全局存在相同的情况
key作为一个表示并不会传递到对应组件内部，如果需要与key属性值将它们


##### 在JSX中嵌入map

JSX中可以通过用大括号括起来嵌入任何表达式，所以我们可以在其中添加map方法(将map方法从函数中抽离，放到jsx语法中)

#### Form表单

React中的Form表单的工作与其他DOM元素不同，因为form表单通常保存着一些内部状态。
在React中如果不设置js函数去控制表单的提交，则默认为原生DOM的表单提交方式

##### (被)控制部件 ( 用来控制表单的提交行为 )

在HTML中，表单元素<input> <textarea> <select> 元素包含他们自己的状态并且根据用户输入进行更新。
在React中，可变状态特别保存在组件的state属性中，并且只能通过setState()方法来更新。
我们可以合并这两种特性使得React的state为 __单一数据源__ . 这样渲染成fomr元素的React组件也可以根据用户输入控制其行为。
在这样的情况下，被React控制输入值的输入框被称作 (被)控制部件
对于控制组件来讲，每个状态变化都会有一个关联的事件处理函数。


##### textarea标签
在HTML中，不同于其他表单元素，textarea的值被定义为它的文本子节点而非value属性。
而在React中，textarea标签则使用value属性来代替其内容。
因此，textarea的使用方法和其他表单元素相同

##### select标签
在HTML中，select标签生成下拉表单。
在HTML中通过设置selected属性去设置被选中选项。
在React中则是通过根select标签的value属性去设置选中选项(option的value属性)。在控制组件中这样更加方便，因为你只需要通过在一个位置更新该属性。

##### 处理多个输入框

当需要处理多个input控制组件时，可以给每个input组件添加name属性程序使得事件处理程序对根据event.target.name(对应input标签的name属性)对状态进行操作


##### 控制组件的替代品

控制组件不好的地方在于对于数据的任何一种变化方式都需要书写事件处理程序并需要通过React组件去传输所有输入状态。


#### 状态提升

经常会有几个组建需要反映下相同的变化数据。此时我们建议提升状态到他们共有的最近的祖先。

##### 经验教训

在React应用中，对于任何数据变化只能有一个数据来源。
通常首先将状态添加到需要渲染的组件中
然后，如果其他组件也需要该状态，你可以将该状态提升到最近的公共祖先组件中。


#### 组合(Composition)与继承(Inheritance)

React有着强大的组合模型，建议在组件之间使用组合而非继承的方式复用代码

##### 遏制

一些组件通常并不能提前知晓他们的子组件。
在这种情况下，我们建议这样的组件通过prop中的children属性直接将子组件DOM结构传递到该组件的输出中。

在JSX语法中，任何在标签内部的字符串都作为children prop传递到组件的 构造/render 方法中.

在JSX语法中，组件DOM结构(<Example />)可以看作对象一样传递到其他组件的DOM结构中作为属性传递进去，然后将其以类似childrend的方式放置到该组件的内部作为其子组件

##### 定制化

有时我们认为组件是其他一些组件特殊情况下的产物。
比如 "欢迎对话框" 是 对话框的特殊情况。

在React中，更定制化的组件渲染一个更通用的组件并且对其通过props进行配置

##### 继承

props和组合有着无限的灵活度让工程师自由定制组件的结构(look)和行为

    组件可以接受任意props,包括原始值，React组件，函数

如果想在组件之间复用非UI功能，我们建议提取该组件到一个独立的JS模块。其他组件可以引入该组件宾切使用该function，object，class而不需要extend它.

#### 重新思考React

React帮助你在构建App时更好的理解应用的组成(组件化思考方式)。在控制组件中这样更加方便，因为你只需要通过在一个位置更新该属性。

##### 

根据单一职责原则划分组件

当组件中有些不变DOM存在扩展可能时，需要将其单独分割为一个组件而不是继续放置在之前的父组件中。

自上而下的设计和自下而上的设计的优缺点

__React单向绑定__



##### 确定必需的最小(但完整)的UI状态的state

DRY原则：不要重复自己的工作

__确定必需的用于UI展示的state，其他的非必需则通过计算获得__

对于需要的数据，进行判断来对数据进行props和state的分类:

1. 是否可以从祖先组件传递获得？ 是，则该数据不是state
2. 是否总是不发生变化？ 是，则该数据不是sate
3. 是否可以根据其他state计算获得？ 是，则该数据不是state








